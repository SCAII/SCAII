mod universal_messages;

pub use self::universal_messages::*;

use std::fmt::{Display, Formatter};
use std::fmt;

/// Merges a bunch of `MultiMessage`s into a new one.
///
/// The result will preserve the order of the input multimessages.
///
/// If `msgs` is empty, `None` is returned. If it's of length 1,
/// that `MultiMessage` will be returned without modification.
pub fn merge_multi_messages(mut msgs: Vec<MultiMessage>) -> Option<MultiMessage> {
    if msgs.len() == 0 {
        return None;
    } else if msgs.len() == 1 {
        return msgs.pop();
    }

    // Scope so split_first_mut borrow ends
    {
        let (first, tail) = msgs.split_first_mut().unwrap();

        for msg in tail {
            for packet in msg.take_packets().into_iter() {
                first.mut_packets().push(packet);
            }
        }
    }

    Some(msgs.swap_remove(0))
}


/// The destination or source of a routed message
///
/// Just a Rust-friendly version of
/// Of the autogenerated endpoint.
#[derive(Clone, PartialEq, Eq, Debug)]
pub enum RouterEndpoint {
    Backend,
    Agent,
    Core,
    Module { name: String },
}

impl RouterEndpoint {
    /// Creates a RouterEndpoint from an Endpoint struct failing if no name
    /// is provided for a module.
    pub fn from_endpoint(endpoint: &Endpoint) -> Self {
        if endpoint.has_backend() {
            RouterEndpoint::Backend
        } else if endpoint.has_agent() {
            RouterEndpoint::Agent
        } else if endpoint.has_core() {
            RouterEndpoint::Core
        } else {
            let module = endpoint.get_module();
            RouterEndpoint::Module { name: module.get_name().to_string() }
        }

    }

    /// Changes this back to an Endpoint proto struct. Usable for sending
    /// messages.
    pub fn to_endpoint(&self) -> Endpoint {
        let mut end = Endpoint::new();
        match *self {
            RouterEndpoint::Backend => {
                end.set_backend(BackendEndpoint::new());
            }
            RouterEndpoint::Agent => {
                end.set_agent(AgentEndpoint::new());
            }
            RouterEndpoint::Core => {
                end.set_core(CoreEndpoint::new());
            }
            RouterEndpoint::Module { ref name } => {
                let mut mod_end = ModuleEndpoint::new();
                mod_end.set_name(name.clone());
                end.set_module(mod_end);
            }
        };

        end
    }
}

impl Display for RouterEndpoint {
    fn fmt(&self, fmt: &mut Formatter) -> Result<(), fmt::Error> {

        match *self {
            RouterEndpoint::Backend => write!(fmt, "{}", "backend"),
            RouterEndpoint::Agent => write!(fmt, "{}", "agent"),
            RouterEndpoint::Core => write!(fmt, "{}", "core"),
            // The (module) helps disambiguate if someone registered a module with,
            // say, the name "backend". They'd see "backend (module)" instead.
            RouterEndpoint::Module { ref name } => write!(fmt, "{} (module)", name),
        }

    }
}