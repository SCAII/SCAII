extern crate scaii_core;
extern crate docopt;
extern crate scaii_defs;
extern crate bincode;
extern crate prost;
extern crate url;
extern crate serde;
#[macro_use]
extern crate serde_derive;

use prost::Message;
use protos::{scaii_packet, Cfg, CoreEndpoint, BackendInit, MultiMessage, ScaiiPacket,
             BackendEndpoint, ModuleEndpoint, plugin_type, PluginType, ReplayEndpoint, RecorderConfig, ReplayStep,
             ReplaySessionConfig, RustFfiConfig};
use protos::cfg::WhichModule;
use protos::user_command::UserCommandType;
use protos::endpoint::Endpoint;
use protos::scaii_packet::SpecificMsg;
use scaii_core::{Environment, ScaiiConfig};
use scaii_core::{SerializedProtosSerializationResponse, SerializedProtosScaiiPacket, GameAction,
                 ReplayAction, ReplayHeader};
use scaii_defs::protos;
use scaii_defs::{Module, Replay};
use std::error::Error;
use std::{thread, time};
use std::rc::Rc;
use std::cell::RefCell;
use std::fmt;
use std::sync::{Arc, mpsc, Mutex};
use std::fs::File;
use std::path::{Path, PathBuf};
use std::io::BufReader;
use bincode::{deserialize_from, Infinite};
//use serde::Deserialize;
//use docopt::Docopt;
use std::env;
use scaii_core::util;

mod test_util;
use test_util::*;
mod webserver;
use webserver::launch_webserver;

const USAGE: &'static str = "
replay.

Usage:
  replay webserver
  replay file [--filename <path-to-replay-file>]
  replay test [--data-hardcoded | --data-from-recorded-file]
  replay (-h | --help)

Options:
  --filename=<path-to-replay-file>  path to the replay file to run.
  --data_hardcoded              data generated within local replay tester code.
  --data_from_recorded_file     data generated by recorder test output file.
  -h --help                     Show this screen.
";

#[derive(Debug, Deserialize)]
struct Args {
    cmd_webserver: bool,
    //
    cmd_test: bool,
    flag_data_from_recorded_file: bool,
    flag_data_hardcoded: bool,
    //
    cmd_file: bool,
    flag_filename: bool,
    arg_path_to_replay_file: String,
    //flag_backend: bool,
    //arg_path_to_backend: String,
}



#[derive(Debug)]
struct ReplayError {
    details: String,
}

impl ReplayError {
    fn new(msg: &str) -> ReplayError {
        ReplayError { details: msg.to_string() }
    }
}

impl fmt::Display for ReplayError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.details)
    }
}

impl Error for ReplayError {
    fn description(&self) -> &str {
        &self.details
    }
}

#[derive(Debug)]
enum GameState {
    Running,
    Paused,
    RewoundAndNeedingToSendInitialKeyframe,
    JumpedAndNeedingToDoFollowupNavigation,
}

/// Replay owns the environment, but we need this
/// inside the environment (router) to collect messages
struct ReplayMessageQueue {
    incoming_messages: Vec<protos::ScaiiPacket>,
}

impl Module for ReplayMessageQueue {
    fn process_msg(&mut self, msg: &ScaiiPacket) -> Result<(), Box<Error>> {
        self.incoming_messages.push(msg.clone());
        Ok(())
    }

    /// return empty messages
    fn get_messages(&mut self) -> MultiMessage {
        let pkts: Vec<ScaiiPacket> = Vec::new();
        MultiMessage { packets: pkts }
    }
}

impl Replay for ReplayMessageQueue {}


struct ReplayManager {
    incoming_message_queue: Rc<RefCell<ReplayMessageQueue>>, // going to go in router
    step_delay: Arc<Mutex<u64>>,
    poll_delay: Arc<Mutex<u64>>,
    shutdown_received: bool,
    env: Environment,
    replay_data: Vec<ReplayAction>,
    step_position: u64,
    test_mode: bool,
    args: Args,
}

impl ReplayManager {
    fn start(&mut self) -> Result<(), Box<Error>> {
        // startup viz via rpc
        let mm = wrap_packet_in_multi_message(create_rpc_config_message()?);
        self.env.route_messages(&mm);
        self.env.update();
        // pull off header and configure
        let header: ReplayAction = self.replay_data.remove(0);
        self.configure_as_per_header(header)?;
        let steps = self.replay_data.len() as i64;
        let mm = wrap_packet_in_multi_message(self.create_replay_session_config_message(steps));
        self.env.route_messages(&mm);
        self.env.update();

        self.run_and_poll()
    }

    fn create_replay_session_config_message(&mut self, steps: i64) -> ScaiiPacket {
        ScaiiPacket {
            src: protos::Endpoint { endpoint: Some(Endpoint::Replay(ReplayEndpoint {})) },
            dest: protos::Endpoint { endpoint: Some(Endpoint::Backend(BackendEndpoint {})) },
            specific_msg: Some(SpecificMsg::ReplaySessionConfig(
                ReplaySessionConfig { step_count: steps },
            )),
        }
    }

    fn adjust_cfg_packets(&mut self, cfg_pkts : Vec<ScaiiPacket>) -> Result<Vec<ScaiiPacket>, Box<Error>> {
        println!("ARGS is {:?}", self.args);
        let mut temp_vec : Vec<ScaiiPacket> = Vec::new();
        let mut result_vec : Vec<ScaiiPacket> = Vec::new();
        let mut rust_ffi_config_pkt : Option<ScaiiPacket> = None;
        let mut backend_config_pkt : Option<ScaiiPacket> = None;
        for pkt in cfg_pkts {
            match pkt.specific_msg {
                Some(SpecificMsg::Config(Cfg {
                    which_module: Some(WhichModule::BackendCfg(protos::BackendCfg {..}))})) => {
                    backend_config_pkt = Some(pkt);
                },
                Some(SpecificMsg::Config(Cfg {
                    which_module: Some(WhichModule::CoreCfg(protos::CoreCfg {
                        plugin_type: PluginType {
                            plugin_type: Some(plugin_type::PluginType::RustPlugin(RustFfiConfig {..}))
                        }}))})) => {
                    rust_ffi_config_pkt = Some(pkt);
                },
                _ => {
                    temp_vec.push(pkt);
                }
            }
        }
        // if self.args.flag_backend {
        //     // override the specified backend
        //     if rust_ffi_config_pkt != None {
        //         println!("WARNING - Overriding which backend to load...");
        //         let plugin_path =  get_plugin_path_from_rust_ffi_config(&rust_ffi_config_pkt.unwrap())?;
        //         println!("...was        : {}",plugin_path);
        //     }
        //     println!("...backend will be: {}", self.args.arg_path_to_backend);
        //     rust_ffi_config_pkt = Some(create_rust_ffi_config_message(&self.args.arg_path_to_backend)?);
        //     println!("...backend is now: {}", self.args.arg_path_to_backend);
        // }
        //if no backend instance specified yet, use the default 
        if rust_ffi_config_pkt == None {
            let default_backend_path = util::get_default_backend()?;
            rust_ffi_config_pkt = Some(create_rust_ffi_config_message(&default_backend_path)?);
            println!("...using default backend: {}", default_backend_path);
        }
        
        if backend_config_pkt == None {
            println!("...generating default backend config...");
            backend_config_pkt = Some(create_default_replay_backend_config());
        }
        else {
            // need to change replay_mode to true
            println!("...setting replay_mode to true on backend config...");
            set_replay_mode_on_backend_config(&mut backend_config_pkt);
        }
        println!("backend config packet final form is: {:?}", backend_config_pkt);
        println!("rust_ffi_config packet final form is: {:?}", rust_ffi_config_pkt);
        result_vec.push(rust_ffi_config_pkt.unwrap());
        result_vec.push(backend_config_pkt.unwrap());
        for pkt in temp_vec {
            result_vec.push(pkt);
        }
        Ok(result_vec)
    }

    fn emit_cfg_packets(&mut self, cfg_pkts : Vec<ScaiiPacket>) -> Result<(), Box<Error>> {
        for pkt in &cfg_pkts {
            let pkt_to_send = pkt.clone();
            let mm = wrap_packet_in_multi_message(pkt_to_send);
            self.env.route_messages(&mm);
            self.env.update();
        }
        Ok(())
    }

    fn configure_as_per_header(&mut self, header: ReplayAction) -> Result<(), Box<Error>> {
        match header {
            ReplayAction::Header(ReplayHeader {
                                     configs: SerializedProtosScaiiPacket { data: u8_vec },
                                 }) => {
                let pkt = ScaiiPacket::decode(u8_vec)?;
                match pkt.specific_msg {
                    Some(scaii_packet::SpecificMsg::RecorderConfig(RecorderConfig {
                                                                       pkts: pkt_vec,
                                                                   })) => {
                        let adjusted_cfg_pkts = self.adjust_cfg_packets(pkt_vec)?;
                        self.emit_cfg_packets(adjusted_cfg_pkts)
                    }
                    _ => Err(Box::new(ReplayError::new(
                        &format!(
                            "replay action header malformed - should contain RecorderConfig ScaiiPacket {:?}",
                            pkt
                        )
                            [..],
                    ))),
                }
            }
            _ => {
                Err(Box::new(ReplayError::new(
                    &format!(
                        "replay action header malformed - should be ReplayAction::Header(ReplayHeader)... {:?}",
                        header
                    )
                        [..],
                )))
            }
        }
    }

    fn notify_viz_that_jump_completed(&mut self) -> Result<Vec<ScaiiPacket>, Box<Error>> {
        let pkt: ScaiiPacket = ScaiiPacket {
            src: protos::Endpoint { endpoint: Some(Endpoint::Replay(ReplayEndpoint {})) },
            dest: protos::Endpoint {
                endpoint: Some(Endpoint::Module(
                    ModuleEndpoint { name: "RpcPluginModule".to_string() },
                )),
            },
            specific_msg: Some(scaii_packet::SpecificMsg::UserCommand(
                protos::UserCommand {
                    command_type: protos::user_command::UserCommandType::JumpCompleted as i32,
                    args: Vec::new(),
                },
            )),
        };
        let result = self.send_pkt_to_viz(pkt)?;
        Ok(result)
    }

    fn send_pkt_to_viz(&mut self, pkt: ScaiiPacket) -> Result<Vec<ScaiiPacket>, Box<Error>> {
        let mut to_send: Vec<protos::ScaiiPacket> = Vec::new();
        to_send.push(pkt);
        let mm = MultiMessage { packets: to_send };
        self.env.route_messages(&mm);
        self.env.update();
        let scaii_pkts: Vec<protos::ScaiiPacket> = {
            let queue = &mut *self.incoming_message_queue.borrow_mut();
            let result: Vec<protos::ScaiiPacket> = queue.incoming_messages.drain(..).collect();
            //println!("====================got result packets {} ", result.len());
            result
        };
        Ok(scaii_pkts)
    }

    fn poll_viz(&mut self) -> Result<Vec<ScaiiPacket>, Box<Error>> {
        let pkt: ScaiiPacket = ScaiiPacket {
            src: protos::Endpoint { endpoint: Some(Endpoint::Replay(ReplayEndpoint {})) },
            dest: protos::Endpoint {
                endpoint: Some(Endpoint::Module(
                    ModuleEndpoint { name: "RpcPluginModule".to_string() },
                )),
            },
            specific_msg: Some(scaii_packet::SpecificMsg::UserCommand(
                protos::UserCommand {
                    command_type: protos::user_command::UserCommandType::PollForCommands as i32,
                    args: Vec::new(),
                },
            )),
        };
        let result = self.send_pkt_to_viz(pkt)?;
        Ok(result)
    }

    fn has_more_steps(&mut self) -> bool {
        self.step_position <= self.replay_data.len() as u64 - 1
    }

    fn wrap_response_in_scaii_pkt(
        &mut self,
        ser_response: protos::SerializationResponse,
    ) -> ScaiiPacket {
        ScaiiPacket {
            src: protos::Endpoint { endpoint: Some(Endpoint::Replay(ReplayEndpoint {})) },
            dest: protos::Endpoint { endpoint: Some(Endpoint::Backend(BackendEndpoint {})) },
            specific_msg: Some(scaii_defs::protos::scaii_packet::SpecificMsg::SerResp(
                ser_response,
            )),
        }
    }

    fn convert_action_info_to_action_pkt(
        &mut self,
        action: GameAction,
    ) -> Result<ScaiiPacket, Box<Error>> {
        match action {
            GameAction::DecisionPoint(serialized_protos_action) => {
                let protos_action_decode_result =
                    protos::Action::decode(serialized_protos_action.data);
                match protos_action_decode_result {
                    Ok(protos_action) => {
                        Ok(ScaiiPacket {
                            src: protos::Endpoint {
                                endpoint: Some(Endpoint::Replay(ReplayEndpoint {})),
                            },
                            dest: protos::Endpoint {
                                endpoint: Some(Endpoint::Backend(BackendEndpoint {})),
                            },
                            specific_msg: Some(
                                scaii_defs::protos::scaii_packet::SpecificMsg::Action(
                                    protos_action,
                                ),
                            ),
                        })
                    }
                    Err(err) => Err(Box::new(err)),
                }
            }
            GameAction::Step => {
                Ok(ScaiiPacket {
                    src: protos::Endpoint { endpoint: Some(Endpoint::Replay(ReplayEndpoint {})) },
                    dest: protos::Endpoint {
                        endpoint: Some(Endpoint::Backend(BackendEndpoint {})),
                    },
                    specific_msg: Some(scaii_defs::protos::scaii_packet::SpecificMsg::ReplayStep(
                        ReplayStep {},
                    )),
                })
            }
        }

    }

    fn deploy_replay_directives_to_backend(
        &mut self,
        mm: &MultiMessage,
    ) -> Result<Vec<protos::ScaiiPacket>, Box<Error>> {
        self.env.route_messages(mm);
        self.env.update();
        let scaii_pkts: Vec<protos::ScaiiPacket> = {
            let queue = &mut *self.incoming_message_queue.borrow_mut();
            let result: Vec<protos::ScaiiPacket> = queue.incoming_messages.drain(..).collect();
            result
        };
        Ok(scaii_pkts)
    }

    fn send_replay_action_to_backend(&mut self) -> Result<Vec<protos::ScaiiPacket>, Box<Error>> {
        let empty_vec: Vec<protos::ScaiiPacket> = Vec::new();
        let replay_action: ReplayAction = self.replay_data[self.step_position as usize].clone();
        match replay_action {
            ReplayAction::Delta(action) => {
                //println!("REPLAY found delta...");
                let action_pkt: ScaiiPacket = self.convert_action_info_to_action_pkt(action)?;
                let mut pkts: Vec<ScaiiPacket> = Vec::new();
                pkts.push(action_pkt);
                let mm = MultiMessage { packets: pkts };
                let scaii_pkts = self.deploy_replay_directives_to_backend(&mm)?;
                Ok(scaii_pkts)
            }
            ReplayAction::Keyframe(serialization_info, action) => {
                //println!("REPLAY found keyframe...");
                let ser_proto_ser_resp: SerializedProtosSerializationResponse = serialization_info
                    .data;
                let ser_response_decode_result =
                    protos::SerializationResponse::decode(ser_proto_ser_resp.data);
                match ser_response_decode_result {
                    Ok(ser_response) => {
                        let ser_response_pkt: ScaiiPacket =
                            self.wrap_response_in_scaii_pkt(ser_response);
                        let action_pkt: ScaiiPacket =
                            self.convert_action_info_to_action_pkt(action)?;
                        let mut pkts: Vec<ScaiiPacket> = Vec::new();
                        pkts.push(ser_response_pkt);
                        pkts.push(action_pkt);
                        let mm = MultiMessage { packets: pkts };
                        let scaii_pkts = self.deploy_replay_directives_to_backend(&mm)?;
                        Ok(scaii_pkts)
                    }
                    Err(err) => Err(Box::new(err)),
                }

            }
            ReplayAction::Header(_) => Ok(empty_vec),
        }
    }

    fn send_test_mode_jump_to_message(
        &mut self,
        target_step: &String,
    ) -> Result<Vec<protos::ScaiiPacket>, Box<Error>> {
        let target: String = String::from("MockRts");
        let command: String = String::from("jumpTo");
        let mut args_list: Vec<String> = Vec::new();
        args_list.push(target);
        args_list.push(command);
        args_list.push(target_step.clone());
        let pkt: ScaiiPacket = self.create_test_control_message(args_list);
        self.send_packet_to_backend(pkt)
    }

    fn send_packet_to_backend(
        &mut self,
        pkt: ScaiiPacket,
    ) -> Result<Vec<protos::ScaiiPacket>, Box<Error>> {
        let mut pkts: Vec<ScaiiPacket> = Vec::new();
        pkts.push(pkt);
        let mm = MultiMessage { packets: pkts };
        let scaii_pkts = self.deploy_replay_directives_to_backend(&mm)?;
        Ok(scaii_pkts)
    }

    fn create_test_control_message(&mut self, args_list: Vec<String>) -> ScaiiPacket {
        ScaiiPacket {
            src: protos::Endpoint { endpoint: Some(Endpoint::Replay(ReplayEndpoint {})) },
            dest: protos::Endpoint { endpoint: Some(Endpoint::Backend(BackendEndpoint {})) },
            specific_msg: Some(scaii_defs::protos::scaii_packet::SpecificMsg::TestControl(
                protos::TestControl { args: args_list },
            )),
        }
    }

    fn send_test_mode_rewind_hint_message(
        &mut self,
    ) -> Result<Vec<protos::ScaiiPacket>, Box<Error>> {
        let target: String = String::from("MockRts");
        let command: String = String::from("rewind");
        let mut args_list: Vec<String> = Vec::new();
        args_list.push(target);
        args_list.push(command);
        let pkt: ScaiiPacket = self.create_test_control_message(args_list);
        self.send_packet_to_backend(pkt)
    }

    fn send_test_mode_jump_to_hint_message(
        &mut self,
        target_index: u64,
    ) -> Result<Vec<protos::ScaiiPacket>, Box<Error>> {
        let target: String = String::from("MockRts");
        let command: String = String::from("jump");
        let index: String = format!("{}", target_index);
        let mut args_list: Vec<String> = Vec::new();
        args_list.push(target);
        args_list.push(command);
        args_list.push(index);
        let pkt: ScaiiPacket = self.create_test_control_message(args_list);
        self.send_packet_to_backend(pkt)
    }

    fn execute_run_step(&mut self) -> Result<GameState, Box<Error>> {
        let mut game_state: GameState = GameState::Running;
        if self.has_more_steps() {
            let scaii_pkts = self.send_replay_action_to_backend()?;
            self.step_position += 1;
            for scaii_pkt in &scaii_pkts {
                if scaii_defs::protos::is_error_pkt(scaii_pkt) {
                    // Error would have already been shown to user at UI
                    println!(
                        "REPLAY ERROR received as result of run_step {:?}",
                        scaii_pkt
                    );
                } else {
                    println!(
                        "REPLAY unexpected pkt received after sending ReplayAction {:?}",
                        scaii_pkt
                    );
                }
            }
        } else {
            // game will automatically pause at end, switch to polling mode
            game_state = GameState::Paused;
        }
        Ok(game_state)
    }

    fn execute_poll_step(&mut self, mut game_state: GameState) -> Result<GameState, Box<Error>> {
        let scaii_pkts: Vec<ScaiiPacket> = self.poll_viz()?;
        for scaii_pkt in &scaii_pkts {
            if scaii_defs::protos::is_user_command_pkt(scaii_pkt) {
                let user_command_args: Vec<String> =
                    scaii_defs::protos::get_user_command_args(scaii_pkt);
                // we would get args here when they are relevant
                let user_command_type = scaii_defs::protos::get_user_command_type(scaii_pkt)?;
                match user_command_type {
                    UserCommandType::None => {
                        println!("================RECEIVED UserCommandType::None================");
                    }
                    UserCommandType::Explain => {
                        println!(
                            "================RECEIVED UserCommandType::Explain================"
                        );
                    }
                    UserCommandType::Pause => {
                        println!("================RECEIVED UserCommandType::Pause================");
                        game_state = GameState::Paused;
                    }
                    UserCommandType::Resume => {
                        game_state = GameState::Running;
                        println!(
                            "================RECEIVED UserCommandType::Resume================"
                        );
                    }
                    UserCommandType::Rewind => {
                        println!(
                            "================RECEIVED UserCommandType::Rewind================"
                        );
                        self.step_position = 0;
                        if self.test_mode {
                            let _pkts: Vec<ScaiiPacket> =
                                self.send_test_mode_rewind_hint_message()?;
                        }
                        game_state = GameState::RewoundAndNeedingToSendInitialKeyframe;
                    }
                    UserCommandType::PollForCommands => {
                        println!(
                            "================RECEIVED UserCommandType::PollForCommands================"
                        );
                    }
                    UserCommandType::JumpToStep => {
                        println!(
                            "================RECEIVED UserCommandType::JumpToStep================"
                        );
                        println!("args : {:?}", user_command_args);
                        let jump_target: &String = &user_command_args[0];
                        game_state = self.handle_jump_request(jump_target)?;
                    }
                    UserCommandType::JumpCompleted => {} // sent to viz, not received from viz
                    UserCommandType::SetSpeed => {
                        println!(
                            "================RECEIVED UserCommandType::SetSpeed================"
                        );
                        let speed: &String = &user_command_args[0];

                        self.adjust_replay_speed(speed)?;
                    } 
                }
            } else if scaii_defs::protos::is_error_pkt(scaii_pkt) {
                // Error would have already been shown to user at UI
            } else {
                println!(
                    "REPLAY unexpected pkt received by Viz polling {:?}",
                    scaii_pkt
                );
            }
        }
        wait(*self.poll_delay.lock().unwrap());
        Ok(game_state)
    }

    fn adjust_replay_speed(&mut self, speed_string: &str) -> Result<(), Box<Error>> {
        let speed = speed_string.parse::<u64>()?;
        // speed = 0  => 2001 ms or one ~ every 2 seconds
        // speed = 90 => 201 ms or ~ 5/sec,
        // speed = 100 => 1 ms
        let translation_step1: u64 = 100 as u64 - speed;
        let translation_step2: u64 = translation_step1 * 20;
        let msec_delay = translation_step2 + 1;
        println!(" speed string was {} and delay is {}", speed, msec_delay);
        let mut num = self.step_delay.lock().unwrap();
        *num = msec_delay;
        Ok(())
    }

    fn handle_jump_request(&mut self, jump_target: &String) -> Result<GameState, Box<Error>> {
        let result = jump_target.parse::<u32>();
        match result {
            Ok(jump_target_int) => {
                if jump_target_int > self.replay_data.len() as u32 {
                    return Err(Box::new(ReplayError::new(&format!(
                        "Jump target {} not in range of step count {}",
                        jump_target_int,
                        self.replay_data.len()
                    ))));
                }
                self.step_position = u64::from(jump_target_int);
                if self.test_mode {
                    let _pkts: Vec<ScaiiPacket> = self.send_test_mode_jump_to_message(jump_target)?;
                }
            }
            Err(_) => {
                Box::new(ReplayError::new(
                    &format!("Jump target {} not valid number.", jump_target),
                ));
            }
        }

        Ok(GameState::JumpedAndNeedingToDoFollowupNavigation)
    }

    fn get_keyframe_index_prior_to_current_step_position(&mut self) -> Result<u64, Box<Error>> {
        let mut cur_index: u64 = self.step_position;
        let mut seeking: bool = true;
        while seeking {
            let cur_replay_action = &self.replay_data[cur_index as usize];
            match *cur_replay_action {
                ReplayAction::Header(_) => {} // has been removed from list by now - no need to take into account},
                ReplayAction::Delta(_) => {
                    cur_index -= 1;
                }
                ReplayAction::Keyframe(_, _) => {
                    seeking = false;
                }
            }
        }
        Ok(cur_index)
    }

    fn run_and_poll(&mut self) -> Result<(), Box<Error>> {
        let mut game_state: GameState = GameState::Running;
        let (tx_step, rx) = mpsc::channel();
        let (tx_step_ack, rx_step_ack) = mpsc::channel();
        let (tx_poll_ack, rx_poll_ack) = mpsc::channel();
        let tx_poll = mpsc::Sender::clone(&tx_step);
        let arc_poll_delay = Arc::clone(&self.poll_delay);
        // start poll nudge  thread
        let poll_nudge_handle = thread::spawn(move || {
            //let mut i: u64 = 0;
            loop {
                //println!("poll loop sending nudge {}", i);
                //i = i + 1;
                tx_poll.send(String::from("poll_nudge")).unwrap();
                let _ack = rx_poll_ack.recv().unwrap();
                wait(*arc_poll_delay.lock().unwrap());
            }
        });

        let arc_step_delay = Arc::clone(&self.step_delay);
        // start step nudge thread
        let step_nudge_handle = thread::spawn(move || {
            //let mut i: u64 = 0;
            loop {
                //println!("step loop sending nudge {}", i);
                //i = i + 1;
                tx_step.send(String::from("step_nudge")).unwrap();
                let _ack = rx_step_ack.recv().unwrap();
                wait(*arc_step_delay.lock().unwrap());
            }
        });
        //let mut snudge_count : u64 = 0;
        //let mut pnudge_count : u64 = 0;
        while !self.shutdown_received {
            let received = rx.recv();
            match received {
                Ok(nudge) => {
                    match nudge.as_ref() {
                        "step_nudge" => {
                            //println!("main loop got step_nudge {}", snudge_count);
                            //snudge_count = snudge_count + 1;
                            game_state = self.handle_step_nudge(game_state)?;
                            tx_step_ack.send(String::from("ack")).unwrap();
                        }
                        "poll_nudge" => {
                            //println!("main loop got poll_nudge {}", pnudge_count);
                            //pnudge_count = pnudge_count + 1;
                            game_state = self.execute_poll_step(game_state)?;
                            tx_poll_ack.send(String::from("ack")).unwrap();

                        }
                        _ => {}
                    }
                }
                Err(receive_error) => return Err(Box::new(receive_error)),
            }
            //wait(50);
        }
        poll_nudge_handle.join().unwrap();
        step_nudge_handle.join().unwrap();
        Ok(())
    }

    fn handle_step_nudge(&mut self, mut game_state: GameState) -> Result<GameState, Box<Error>> {
        match game_state {
            GameState::Running => {
                game_state = self.execute_run_step()?;
            }
            GameState::Paused => {
                // do nothing
            }
            GameState::RewoundAndNeedingToSendInitialKeyframe => {
                let _ignored_game_state: GameState = self.execute_run_step()?;
                game_state = GameState::Paused; // after rewind, we assume they don't want it to start playing
            }
            GameState::JumpedAndNeedingToDoFollowupNavigation => {
                let backup_target: u64 = self.get_keyframe_index_prior_to_current_step_position()?;
                let forward_target: u64 = self.step_position;
                self.keyframe_to_later_step(backup_target, forward_target)?;
                game_state = GameState::Paused;
            }
        }
        Ok(game_state)
    }

    // this should happen atomically - in between pollings, so no game_state change should be occurring so we can ignore
    fn keyframe_to_later_step(
        &mut self,
        keyframe_index: u64,
        target_index: u64,
    ) -> Result<(), Box<Error>> {
        if self.test_mode {
            let _pkts: Vec<ScaiiPacket> = self.send_test_mode_jump_to_hint_message(keyframe_index)?;
        }
        self.step_position = keyframe_index;
        while self.step_position <= target_index {
            let _game_state = self.execute_run_step()?;
        }
        let _result = self.notify_viz_that_jump_completed()?;
        Ok(())
    }
}

fn wait(milliseconds: u64) {
    let delay = time::Duration::from_millis(milliseconds);
    thread::sleep(delay);
}

fn wrap_packet_in_multi_message(pkt: ScaiiPacket) -> MultiMessage {
    let mut pkts: Vec<ScaiiPacket> = Vec::new();
    pkts.push(pkt);
    MultiMessage { packets: pkts }
}

fn get_mac_browser_launch_command(scaii_config: &mut ScaiiConfig) -> Result<String, Box<Error>> {
    let browser = scaii_config.get_replay_browser();
    let full_url = scaii_config.get_full_replay_http_url();
    Ok(format!("{} {}", browser, full_url))
}

#[allow(unused_assignments)]
fn create_rpc_config_message() -> Result<ScaiiPacket, Box<Error>> {
    let mut scaii_config: ScaiiConfig = scaii_core::load_scaii_config();

    let mut comm: Option<String> = None;
    if cfg!(target_os = "windows") {
        let windows_command_string = scaii_config.get_replay_browser();
        comm = Some(windows_command_string);
    } else if cfg!(target_os = "unix") {
        panic!("rpc config message for unix not yet implemented!");
    } else {
        // mac
        let mac_command_string = get_mac_browser_launch_command(&mut scaii_config)?;
        comm = Some(mac_command_string);
    }

    //
    // Add arguments on windows,but not mac
    //
    let mut vec: Vec<String> = Vec::new();
    if cfg!(target_os = "windows") {
        let target_url = scaii_config.get_full_replay_http_url();
        vec.push(target_url);
    } else if cfg!(target_os = "unix") {
        // will panic earlier in function if we are on unix
    } else {
        // mac adds no arguments - its all in command (workaround to browser launching issue on mac)
    }

    let rpc_config = scaii_core::get_rpc_config_for_viz(comm, vec);

    Ok(ScaiiPacket {
        src: protos::Endpoint { endpoint: Some(Endpoint::Replay(ReplayEndpoint {})) },
        dest: protos::Endpoint { endpoint: Some(Endpoint::Core(CoreEndpoint {})) },
        specific_msg: Some(SpecificMsg::Config(Cfg {
            which_module: Some(WhichModule::CoreCfg(protos::CoreCfg {
                plugin_type: protos::PluginType {
                    plugin_type: Some(protos::plugin_type::PluginType::Rpc(rpc_config)),
                },
            })),
        })),
    })
}

fn load_replay_file(path: &Path) -> Result<Vec<ReplayAction>, Box<Error>> {
    //use super::ReplayAction;
    println!("loading replay file {:?}", path);
    let replay_file = File::open(path).expect("file not found");
    let mut replay_vec: Vec<ReplayAction> = Vec::new();
    let mut reader = BufReader::new(replay_file);

    while let Ok(action) = deserialize_from::<BufReader<File>, ReplayAction, Infinite>(
        &mut reader,
        Infinite,
    )
    {
        replay_vec.push(action);
    }
    Ok(replay_vec)
}

fn load_replay_info_from_default_replay_path() -> Result<Vec<ReplayAction>, Box<Error>> {
    let path = scaii_core::get_default_replay_file_path()?;
    load_replay_info_from_replay_file_path(path)
}
fn load_replay_info_from_replay_file_path(path: PathBuf) -> Result<Vec<ReplayAction>, Box<Error>> {
    let load_result = load_replay_file(&path);
    match load_result {
        Ok(replay_vec) => Ok(replay_vec),
        Err(err) => Err(err),
    }
}
#[allow(dead_code)]
enum RunMode {
    Live,
    Test,
}
fn parse_args(arguments : Vec<String> ) -> Args {
    let mut args = Args {
        cmd_webserver: false,
        cmd_test: false,
        flag_data_from_recorded_file: false,
        flag_data_hardcoded: false,
    
        cmd_file: false,
        flag_filename: false,
        arg_path_to_replay_file: "".to_string(),
    };
//      replay webserver
//  replay file [--filename <path-to-replay-file>]
//  replay test [--data-hardcoded | --data-from-recorded-file]
//  replay (-h | --help)
    let command = &arguments[1];
    match command.as_ref() {
        "webserver" => {
            args.cmd_webserver = true;
        },
        "file" => {
            args.cmd_file = true;
            match arguments.len() {
                2 => {
                    // no further arguments
                }
                4 => {
                    let flag = &arguments[2];
                    match flag.as_ref() {
                        "--filename" => {
                            args.flag_filename = true;
                            let path = &arguments[3];
                            args.arg_path_to_replay_file = path.clone();
                        }
                        _ => {
                            println!("{}", USAGE);
                            std::process::exit(0);
                        }
                    }
                }
                _ => {
                    println!("{}", USAGE);
                    std::process::exit(0);
                }
            }
        },
        "test" => {
            args.cmd_test = true;
            match arguments.len() {
                3 => {
                    let flag = &arguments[2];
                    match flag.as_ref() {
                        "--data-hardcoded" => {
                            args.flag_data_hardcoded = true;
                        },
                        "--data-from-recorded-file" => {
                            args.flag_data_from_recorded_file = true;
                        },
                        _ => {
                            println!("{}", USAGE);
                            std::process::exit(0);
                        }
                    }
                }
                _ => {
                    println!("{}", USAGE);
                    std::process::exit(0);
                }
            }
        },
        &_ => {
            println!("{}", USAGE);
            std::process::exit(0);
        }
    }
    args
}

fn main() {
    let arguments: Vec<String> = env::args().collect();
    println!("{:?}", arguments);
    let args : Args = parse_args(arguments);
    // let args: Args = Docopt::new(USAGE)
    //     .and_then(|d| d.deserialize())
    //     .unwrap_or_else(|e| e.exit());
    if args.cmd_webserver {
        launch_webserver()
    } else if args.cmd_test {
        println!("Running Replay in test mode...");
        if args.flag_data_from_recorded_file {
            println!("..loading replay data from default path...");
            let replay_info: Vec<ReplayAction> =
                load_replay_info_from_default_replay_path().expect(
                    "Error - problem generating test replay_info",
                );
            run_replay(RunMode::Test, replay_info, args);
        } else {
            println!("...loading hardcoded replay data...");
            // must be flag_data_hardcoded
            let step_count: u32 = 300;
            let interval: u32 = 5;
            let replay_info = concoct_replay_info(step_count, interval).expect(
                "Error - problem generating test replay_info",
            );
            run_replay(RunMode::Test, replay_info, args);
        }
    } else if args.cmd_file {
        println!("Running replay in live mode...");
        if args.flag_filename {
            println!("...replay filepath overridden as {}", &args.arg_path_to_replay_file);
            let replay_info: Vec<ReplayAction> = {
                let path = Path::new(&args.arg_path_to_replay_file);
                if !path.exists() {
                    panic!("ERROR - specified replay path does not exist {:?}", path);
                }
                //println!("calling load_replay_info_from_replay_file_path...");
                load_replay_info_from_replay_file_path(path.to_path_buf())
                    .expect("Error - problem generating test replay_info")
            };
            run_replay(RunMode::Live, replay_info, args);
        }
        else {
            println!("...replay file will be loaded from default location...");
            let replay_info: Vec<ReplayAction> = {
                //println!("calling load_replay_info_from_default_replay_path...");
                load_replay_info_from_default_replay_path()
                .expect("Error - problem generating replay_info from default file")
            };
            run_replay(RunMode::Live, replay_info, args);
        }
    } else {
        panic!("Unrecognized command mode for replay: {:?}", args);
    }
}

#[allow(unused_assignments)]
fn run_replay(run_mode: RunMode, replay_info: Vec<ReplayAction>, args: Args) {
    let mut mode_is_test = true;
    let mut environment: Environment = Environment::new();

    match run_mode {
        RunMode::Test => {
            configure_and_register_mock_rts(&mut environment);
        }
        RunMode::Live => {
            mode_is_test = false;
        }
    }

    let replay_message_queue = ReplayMessageQueue { incoming_messages: Vec::new() };
    let rc_replay_message_queue = Rc::new(RefCell::new(replay_message_queue));
    {
        environment.router_mut().register_replay(Box::new(
            Rc::clone(&rc_replay_message_queue),
        ));
        debug_assert!(environment.router().replay().is_some());
    }
    let mut replay_manager = ReplayManager {
        incoming_message_queue: rc_replay_message_queue,
        step_delay: Arc::new(Mutex::new(201)),
        poll_delay: Arc::new(Mutex::new(50)),
        shutdown_received: false,
        env: environment,
        replay_data: replay_info,
        step_position: 0,
        test_mode: mode_is_test,
        args: args,
    };
    let result = replay_manager.start();
    match result {
        Ok(_) => {}
        Err(e) => {
            println!("Replay Error {:?}", e);
            return;
        }
    }
}

fn configure_and_register_mock_rts(env: &mut Environment) {
    let rts = MockRts {
        viz_sequence: Vec::new(),
        outbound_messages: Vec::new(),
        step_position: 0,
        step_count: 0,
        sent_viz_init: false,
    };

    {
        env.router_mut().register_backend(Box::new(rts));
    }
}


fn get_rust_ffi_config_for_path(path: &str) -> RustFfiConfig {
    RustFfiConfig {
        plugin_path: path.to_string(),
        init_as: protos::InitAs { init_as: Some(protos::init_as::InitAs::Backend(BackendInit {})) },
    }
}

fn create_rust_ffi_config_message(backend_path: &str) -> Result<ScaiiPacket, Box<Error>> {
    use scaii_defs::protos::plugin_type::PluginType;
    let path = Path::new(backend_path);
    if !path.exists() {
        return Err(Box::new(ReplayError::new(
            &format!("specified backend does not exist {}", backend_path),
        )));
    }
    let rust_ffi_config = get_rust_ffi_config_for_path(backend_path);
    Ok(ScaiiPacket {
        src: protos::Endpoint { endpoint: Some(Endpoint::Replay(ReplayEndpoint {})) },
        dest: protos::Endpoint { endpoint: Some(Endpoint::Core(CoreEndpoint {})) },
        specific_msg: Some(SpecificMsg::Config(Cfg {
            which_module: Some(WhichModule::CoreCfg(protos::CoreCfg {
                plugin_type: protos::PluginType {
                    plugin_type: Some(PluginType::RustPlugin(rust_ffi_config)),
                },
            })),
        })),
    })
}

fn get_plugin_path_from_rust_ffi_config(pkt : &ScaiiPacket) -> Result<String, Box<Error>> {
    match pkt.specific_msg {
        Some(SpecificMsg::Config(protos::Cfg {
                    which_module: Some(WhichModule::CoreCfg(protos::CoreCfg {
                        plugin_type: PluginType {
                            plugin_type: Some(plugin_type::PluginType::RustPlugin(ref rust_ffi_config))
                        }
                    }))})) => { 
                        Ok(rust_ffi_config.plugin_path.clone())
                    },
        _ => {
            Err(Box::new(ReplayError::new(
            &format!("ERROR - no plugin_path was found in supposedRustFfiConfig pkt {:?}", pkt),
        )))},
    }
}

fn create_default_replay_backend_config() -> ScaiiPacket {
    let vec : Vec<u8> = Vec::new();
    ScaiiPacket {
        src: protos::Endpoint { endpoint: Some(Endpoint::Replay(ReplayEndpoint {})) },
        dest: protos::Endpoint { endpoint: Some(Endpoint::Backend(BackendEndpoint {})) },
        specific_msg: Some(SpecificMsg::Config(protos::Cfg {
                which_module: Some(WhichModule::BackendCfg(protos::BackendCfg {
                    cfg_msg: Some(vec),
                    is_replay_mode: true,
                }))
        }))
    }
}

fn set_replay_mode_on_backend_config(packet_option : &mut Option<ScaiiPacket>) {
    if let &mut Some(ScaiiPacket {
        specific_msg: Some(SpecificMsg::Config(protos::Cfg {
                which_module: Some(WhichModule::BackendCfg(protos::BackendCfg {
                    ref mut is_replay_mode,
                       ..
                }))
        })), ..}) = packet_option {
      *is_replay_mode = true;
     }
}